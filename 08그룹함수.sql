--그룹함수:여러행에 대하여 집계출력
--AVG, SUM, MIN, MAX, COUNT
SELECT AVG(SALARY), SUM(SALARY), MIN(SALARY), MAX(SALARY), COUNT(SALARY) FROM EMPLOYEES;
SELECT MIN(HIRE_DATE), MAX(HIRE_DATE) FROM EMPLOYEES;
SELECT MIN(FIRST_NAME), MAX(FIRST_NAME) FROM EMPLOYEES;

--COUNT(컬럼):NULL이 아닌 데이터 개수
--COUNT(*):전체행의 개수
SELECT COUNT(FIRST_NAME) FROM EMPLOYEES;
SELECT COUNT(COMMISSION_PCT) FROM EMPLOYEES;
SELECT COUNT(DISTINCT DEPARTMENT_ID) FROM EMPLOYEES;
SELECT COUNT(*) FROM EMPLOYEES;

--그룹함수: 그룹함수와 일반컬럼을 동시에 출력할 수 없다. (오라클만)
--그룹화 시켜놓은 컬럼만 사용할 수 있다.
SELECT FIRST_NAME, SUM(SALARY) FORM EMPLOYEES; --오류

--------------------------------------------------------------------------------
SELECT DEPARTMENT_ID, AVG(SALARY), SUM(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID 
ORDER BY DEPARTMENT_ID;

--주의할점
SELECT DEPARTMENT_ID
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;
--
SELECT DEPARTMENT_ID, JOB_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;
--그룹함수를 WHERE절에 적용할 수 없다.
SELECT JOB_ID, AVG(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 50
GROUP BY JOB_ID;
--그룹의 조건은 HAVING절
SELECT JOB_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY) >= 10000;

SELECT DEPARTMENT_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) >= 30;

SELECT JOB_ID, SUM(SALARY), SUM(NVL(COMMISSION_PCT, 0))
FROM EMPLOYEES
WHERE JOB_ID NOT IN('IT_PROG')
GROUP BY JOB_ID
HAVING SUM(SALARY) >= 20000
ORDER BY SUM(SALARY) DESC;
-- 부서아이디가 50번 이상인 부서를 그룹화 시키고 그룹평균급여 5000이상만 출력

SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID > 50
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) > 5000;

SELECT FIRST_NAME, COUNT(*)
FROM EMPLOYEES
GROUP BY FIRST_NAME;

--ROLLUP - 각 그룹의 소계, 총계를 아래에 출력
SELECT DEPARTMENT_ID, TRUNC(AVG(SALARY))
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID);

SELECT DEPARTMENT_ID, JOB_ID, TRUNC(SUM(SALARY))
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID;

--CUBE : 서브그룹에 대한 컬럼출력
SELECT DEPARTMENT_ID, JOB_ID, TRUNC(AVG(SALARY))
FROM EMPLOYEES
GROUP BY CUBE(DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID;

--GROUPING() : 그룹절로 생성되면 0반환, 롤업OR큐브로 만들어지면 1반환
SELECT DEPARTMENT_ID, JOB_ID, DECODE(GROUPING(JOB_ID), 1, '소계', JOB_ID ),GROUPING(DEPARTMENT_ID), GROUPING(JOB_ID), SUM(SALARY), COUNT(*)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID;

--연습문제-----------------------------------------------------------------------
--문제1
SELECT JOB_ID, COUNT(JOB_ID), AVG(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY AVG(SALARY) DESC;

--문제2
SELECT SUBSTR(HIRE_DATE, 1, 2) AS 입사년도, COUNT(HIRE_DATE)
FROM EMPLOYEES
GROUP BY SUBSTR(HIRE_DATE, 1,2);

--문제2(선생님풀이)
SELECT TO_CHAR(HIRE_DATE, 'YY'), COUNT(*)
FROM EMPLOYEES
GROUP BY TO_CHAR(HIRE_DATE, 'YY');

--문제3
SELECT DEPARTMENT_ID, 
       TRUNC( AVG(SALARY) ) -- 2번
FROM EMPLOYEES
WHERE SALARY >= 1000  -- 1번
GROUP BY DEPARTMENT_ID
HAVING TRUNC( AVG(SALARY) )>= 2000;

--문제4
SELECT DEPARTMENT_ID, 
       TRUNC(AVG(SALARY + SALARY * COMMISSION_PCT),2) AS 급여평균, 
       SUM(SALARY + SALARY * COMMISSION_PCT) AS 급여합,
       COUNT(*) AS 사원수
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL
GROUP BY DEPARTMENT_ID;

--문제5
SELECT DECODE(GROUPING(JOB_ID), 1, '합계',JOB_ID), SUM(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;

--문제6
SELECT DECODE(GROUPING(DEPARTMENT_ID), 1, '합계', DEPARTMENT_ID) AS DEPARTMENT_ID, 
       DECODE(GROUPING(JOB_ID), 1,'소계', JOB_ID) AS JOB_ID, 
       COUNT(*) AS TOTAL, 
       SUM(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)
ORDER BY SUM(SALARY);



